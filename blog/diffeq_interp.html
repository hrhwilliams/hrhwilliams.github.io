<!DOCTYPE html>
<html>
    <head>
        <title>Writing A Differential Equation Interpreter, Part 1</title>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="stylesheet" type="text/css" href="/static/style.css">
        <link rel="stylesheet" type="text/css" href="/static/fonts.css">
        <script type="text/javascript" src="/static/scripts.js"></script>

        <!-- KaTeX -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

        <script>
            window.WebFontConfig = {
                custom: {
                families: ['KaTeX_AMS', 'KaTeX_Caligraphic:n4,n7', 'KaTeX_Fraktur:n4,n7',
                    'KaTeX_Main:n4,n7,i4,i7', 'KaTeX_Math:i4,i7', 'KaTeX_Script',
                    'KaTeX_SansSerif:n4,n7,i4', 'KaTeX_Size1', 'KaTeX_Size2', 'KaTeX_Size3',
                    'KaTeX_Size4', 'KaTeX_Typewriter'],
                },
            };
        </script>
        
        <!-- highlight.js -->
        <link rel="stylesheet" type="text/css" href="/highlight/styles/mono-blue.min.css">
        <script type="text/javascript" src="/highlight/highlight.min.js"></script>
        <script>hljs.highlightAll();</script>

        <script defer src="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.js" integrity="sha256-4O4pS1SH31ZqrSO2A/2QJTVjTPqVe+jnYgOWUVr7EEc=" crossorigin="anonymous"></script>
    </head>
    <body>
        <header>
        <hr>
        <nav role="navigation">
            <a href="/">Home</a>
            <a href="/blog">Blog</a>
            <a href="/about">About</a>
        </nav>
        <hr>
        </header>
        <main>
        <article>
            <header>
                <h1 class="title">Writing A Differential Equation Interpreter, Part 1</h1>
                <h2 class="date">July 17, 2021</h2>
            </header>

<p>
(Under Construction)
I think differential equations are neat. Many physical processes are modeled by
them. ... My interest in them lead me to explore methods for computationally
‘solving’ for them, or more correctly, numerically integrating them, and this
article is meant to tell the story of my journey learning more about numerical
integration, and eventually my attempting to write a small algebra program to
transform arbitrary equations entered by a user into something that can be solved
and displayed as a plot.
</p>
<h1>Ordinary Differential Equations</h1>
<p>
To keep things simple, I’m only talking about ordinary differential equations
(ODEs), which are differential equations of a single variable. An ordinary
function of a single variable expresses a relation between one value and another,
<span class="math inline">\(y(x)\)</span>. Graphically, this gives you a bunch of points <span class="math inline">\((x, y(x))\)</span> that trace one
curve. On the other hand, an ODE often depends on both <span class="math inline">\(x\)</span> and the current value
of the function <span class="math inline">\(y(x)\)</span>, and for higher order ODEs, one or more derivatives of
<span class="math inline">\(y(x)\)</span>. Given the point <span class="math inline">\((x, y(x))\)</span> for a hypothetical solution <span class="math inline">\(y(x)\)</span>, an ODE
returns the slope at that point. I say ‘hypothetical’ because an ODE can have not
just one function as its solution, but an entire family. For example, the family
of solutions to the first-order ODE
</p>
<span class="math display">\[
\frac{\text{d}y}{\text{d}x} = -2xy
\]</span>
<p>
can be found by multiplying both sides by <span class="math inline">\(\text{d}x\)</span>, dividing by <span class="math inline">\(y\)</span>, and
integrating:
</p>
<span class="math display">\[\begin{aligned}
&\int \frac{\text{d}y}{y} = -\int 2x\,\text{d}x \\
&\ln y = - x^{2} + c \\
&y = e^{-x^{2} + c} \\
&y = ce^{-x^{2}},
\end{aligned}\]</span>
<p>
and setting the constant <span class="math inline">\(c\)</span> to any number gives you a function that solves the
initial equation, as
</p>
<span class="math display">\[
\frac{\text{d}}{\text{d}x}\left(ce^{-x^{2}}\right) =
-2x\left(ce^{-x^{2}}\right).
\]</span>
<p>
Finding a particular solution, <i>i.e.</i> the solution <span class="math inline">\(y(x)\)</span>that goes
through the point <span class="math inline">\((x, y(x))\)</span> involves specifying an initial value of the
function at <span class="math inline">\(x\)</span> and solving for the constant. If you think of the ODE as itself a
function of two variables,
</p>
<span class="math display">\[
\frac{\text{d}y}{\text{d}x} = f(x, y(x)),
\]</span>
<p>
then there’s a value at any point on the plane, just with the catch that the
second variable is dependent on the first, so that once you pick a point, you are
constrained to the curve given by <span class="math inline">\(y(x)\)</span>.
</p>
<h1>Euler’s Method</h1>
<p>
Finding the exact solution of ODEs is complicated, and not every method works for
every ODE, so it would be nice if there was some algorithm that we could use to
at most approximate a solution given an ODE. Fortunately Euler comes to the
rescue like always, and so there's an algorithm for doing just that named after
him. Given one initial point <span class="math inline">\((x_{0}, y_{0})\)</span>, the slope at that point is given
exactly. Simply draw a straight line with that slope, advance a distance <span class="math inline">\(h\)</span>, and
then evaluate the ODE at the point <span class="math inline">\((x_{0} + h, y(x_{0} + h))\)</span>.
</p>
<p>
Formally, this method of solving, or ‘integrating’, the ODE can be derived from
the definition of the derivative. The derivative of a function can be
approximated by evaluating it at two points a number <span class="math inline">\(h\)</span> apart,
</p>
<span class="math display">\[
\frac{\text{d}y}{\text{d}x} \approx \frac{y(x + h) - y(x)}{h},
\]</span>
<p>
and of course as <span class="math inline">\(h\)</span> approaches zero, the approximation gets better and better.
This can be rearranged to give an iterative way of solving a differential
equation:
</p>
<span class="math display">\[
y(x + h) \approx y(x) + h\frac{\text{d}y}{\text{d}x}.
\]</span>
<p>
or, substituting in <span class="math inline">\(f(x, y(x))\)</span>,
</p>
<span class="math display">\[
y(x + h) \approx y(x) + hf(x, y(x)).
\]</span>
<p>
If each step <span class="math inline">\(h\)</span> is the same size, then we can make an inductive formula for
solving for <span class="math inline">\(y(x)\)</span> starting from <span class="math inline">\((x_{0}, y_{0})\)</span>:
</p>
<span class="math display">\[\begin{aligned}
&x_{n+1} = x_{n} + h \\
&y_{n+1} = y_{n} + hf(x_{n}, y_{n}).
\end{aligned}\]</span>
<p>
This is something we can code up in Python. We’ll create the function <code>step</code> to
take the function at a point, and return a new point after following Euler’s
method for a distance of <code>step_size</code>, and the function <code>eulers_method</code>
to iteratively apply <code>step</code> given initial conditions <span class="math inline">\(x_0, y_0\)</span> up to
a final value <span class="math inline">\(x_f\)</span>. We can leave the actual <code>step_size</code> predefined
for now, but as you might guess there is no perfect <code>step_size</code>. In fact, there’s a <a href="https://en.wikipedia.org/wiki/Adaptive_step_size">lot of math just
to find the optimal step size</a> for an ODE, some of which I might get into in a part 2.
</p>
<pre><code class="language-python">def step(f, x_n, y_n, step_size):
    return y_n + (step_size * f(x_n, y_n))


def eulers_method(f, x_initial, y_initial, x_final):
    step_size = 0.01
    x, y = [x_initial], [y_initial]
    x_n, y_n = x_initial, y_initial

    while x_n &lt;= x_final:
        x_n += step_size
        y_n = step(f, x_n, y_n, step_size)
        x.append(x_n)
        y.append(y_n)
    return x, y</code></pre>
<p>
Then, if we store the output in two arrays, we can use Pyplot to display the solution:
</p>
<pre><code class="language-python">def f(x, y):
    return -2 * x * y

x, y = eulers_method(f, x_initial=-2.5, y_initial=0.01, x_final=2.5)

plt.plot(x, y, c='black')
plt.grid(color='gray', linestyle=':', linewidth=1)
plt.show()</code></pre>

<img src="/blog/images/diffeq_interp_solution.png" alt="Solution to the differential equation y'=-2xy">

<h1>A Grammar for a Differential Equation</h1>
<p>
Believe it or not, the solving of the differential equations in
this way was the easy part, at least programming-wise. As possibly
complicated the math concept is, at the end of the day, it’s just
a bunch of arithmetic that gives us what we want, a series of
points from an initial point that approximate the solution to a
certain differential equation. The hard part is what I wanted to
do next, write an interpreter that would let a user just type in a
few initial conditions and an equation, and have the interpreter
solve the equation and spit out a graph.

Overall, what this entails is:
</p>
<ol>
<li>Transforming a string of text into useful pieces.</li>

<li>Making sure those pieces follow a certain ‘structure’, or grammar.</li>

<li>Performing some algebraic transformations on the pieces if they aren’t
in a certain expected form. (<i>e.g.</i> transforming <span class="math inline">\(y' - y = x\)</span>
into <span class="math inline">\(y' = y + x\)</span> if the latter is easier to evaluate.)</li>

<li>Assembling a function from those pieces that can actually be
interpreted and used in something like the <code>eulers_method</code> method from before.</li>
    
<li>Doing the actual numerical integration and returning a result.</li>
</ol>
<p>
Step one is simple enough. We want to break up strings into tokens, which are in essence
the smallest pieces of the string we care about for the purpose of understanding it. These
tokens are things like numbers, letters as variables, symbols like plus, minus, equals, and
most importantly the apostrophe to denote derivatives. A string like <code>y' = -2 * x * y</code>
might look like, as an array of tokens, <code>[VAR, QUOTE, EQUALS, MINUS, NUM, STAR, VAR, STAR, VAR]</code>,
abbreivating variable as <code>VAR</code> and number as <code>NUM</code>.
</p>
<p>
Now to implement something that does this transformation.
We’ll create a data class called <code>Token</code> to store a token symbol such as <code>VAR</code>, as well as
an optional value associated with the specific token, such as ‘y’, or for a <code>NUM</code> token, a value like
2.1828. Now we begin looking through an input string character by character. Some tokens we can identify in a 
single character, such as the symbols ‘+’, ‘-’, ‘*’, ‘/’, ‘=’, ‘'’. Others we’ll need to look ahead, like numbers or
multi-character symbols. To keep things simple, variables will be limited to single characters, so there is no need
to do look ahead for those.
</p>
<pre><code class="language-python">class Token:
    def __init__(self, token, value=None):
        self.token = token
        self.value = value


def tokenize(string):
    tokens = []
    i = 0
    while True:
        if i > len(string) - 1:
            break
        c = string[i]
        if whitespace(c):
            i += 1
        elif number(c):
            num, i = read_number(string, i)
            tokens.append(Token('NUM', num))
        elif variable(c):
            tokens.append(Token('VAR', c))
            i += 1
        elif symbol(c):
            tokens.append(Token(c))
            i += 1
        elif c == ':':
            if i + 1 < len(string) and string[i + 1] == '=':
                tokens.append(Token(':='))
                i += 2
            else:
                raise RuntimeError('Expected :=')
        else:
            raise RuntimeError('Invalid token')
    return tokens</pre></code>
<p>
The next step is much more involved. Now we want to create a grammar that relates these
tokens to the structure of an equation which we want to evaluate. There's a particular way
to represent grammars called <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">Backus–Naur form</a>, or BNF.
</p>
<pre>
stmt := term "=" term

term := factor (+, -) term
      | factor

factor := num (*, /) term
        | "(" term ")" (*, /) term
        | "(" term ")"
        | num
        | var

num := (0,...,9)+
</pre>


        </article>
        </main>
    </body>
</html>
